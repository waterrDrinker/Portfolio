@use 'sass:math';
@use 'sass:map';
@use 'sass:list';
@use './media';
@use '../tokens';
@use '@/styles/utils/functions' as f;

@mixin clamp($property, $min-value, $max-value, $options: ()) {
  @if not math.unit($min-value) == rem or not math.unit($max-value) == rem {
    @error "❌ clamp(): $min-value and $max-value must be rem.";
  }

  $defaults: (
    min-breakpoint-key: mobile,
    max-breakpoint-key: ultra,
  );
  $options: map.merge($defaults, $options);
  $min-breakpoint-key: map.get($options, 'min-breakpoint-key');
  $max-breakpoint-key: map.get($options, 'max-breakpoint-key');
  $unit: 'vw';

  // Get viewport values from map
  $min-bp-val: map.get(tokens.$breakpoints, $min-breakpoint-key);
  $max-bp-val: map.get(tokens.$breakpoints, $max-breakpoint-key);

  // Convert rem → unitless
  $min-val: if($min-value == 0, 0, f.strip-unit($min-value));
  $max-val: f.strip-unit($max-value);

  // Convert px → rem (assuming 16px = 1rem)
  $min-bp-rem: f.strip-unit($min-bp-val);
  $max-bp-rem: f.strip-unit($max-bp-val);

  // slope per vw/vh
  $slope: math.div(
    ($max-val - $min-val),
    math.div(($max-bp-rem - $min-bp-rem), 100)
  );

  // y-intersection
  $y-intersection: $min-val - ($slope * math.div($min-bp-rem, 100));

  #{$property}: #{$max-value};
  #{$property}: clamp(
    #{$min-val}rem,
    #{$y-intersection}rem + #{$slope}#{$unit},
    #{$max-val}rem
  );
}

// у меня тут крыша едет
@mixin clamp-bp($property, $values, $axis: 'vw') {
  $defined-bps: map.keys(tokens.$breakpoints);
  $pivot-bp: 'ultra';

  @if not map.has-key(tokens.$breakpoints, $pivot-bp) {
    @error "There's no such breakpoint in breakpoints";
  }

  $order: mobile, tablet, desktop, ultra; // your preferred order

  @if list.length($values) < 1 {
    @error "Should be at least one breakpoint";
  }

  // Validate all keys
  @each $bp in map.keys($values) {
    @if not list.index($defined-bps, $bp) {
      @error "❌ Unknown breakpoint `#{$bp}`. Valid breakpoints are: #{join($defined-bps, ', ')}.";
    }
  }

  // Filling missing breakpoints
  $pivot-bp-val: map.get(tokens.$breakpoints, $pivot-bp);
  $pivot-clamp-val: map.get($values, $pivot-bp);

  @each $bp in $order {
    @if not map.has-key($values, $bp) {
      $bp-val: map.get(tokens.$breakpoints, $bp);
      $calculated-value: calc(($pivot-clamp-val * $bp-val) / $pivot-bp-val);
      $values: map.merge(
        $values,
        (
          $bp: $calculated-value,
        )
      );
    }
  }

  // Loop through pairs and apply clamp
  $len: list.length($order);
  @for $i from 1 through $len - 1 {
    $min-bp: list.nth($order, $i);
    $max-bp: list.nth($order, $i + 1);
    $min-value: map.get($values, $min-bp);
    $max-value: map.get($values, $max-bp);

    @include media.media-min($min-bp) {
      @include clamp(
        $property,
        $min-value,
        $max-value,
        (
          min-breakpoint-key: $min-bp,
          max-breakpoint-key: $max-bp,
          axis: $axis,
        )
      );
    }
  }
}
